<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Finite Element Simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #fff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>

		<script src="../three.js/build/three.min.js"></script>
		<script src="../three.js/examples/js/Detector.js"></script>
		<script src="../three.js/examples/js/libs/dat.gui.min.js"></script>
		
		<script src="js/FM/qf.js"></script>
		<script src="js/FM/qf.mode.js"></script>
		<script src="js/FM/qf.guiCrtl.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;

			var blendMesh, camera, scene, renderer, controls;

			var clock = new THREE.Clock();
			var gui = null;

			var isFrameStepping = false;
			var timeToStep = 0;

			function init() {

				var aspect = window.innerWidth / window.innerHeight;
				//var radius = blendMesh.geometry.boundingSphere.radius;
				var radius = 1000;

				var width = 1000;
				var height = 600;
				
				camera = new THREE.PerspectiveCamera( 45, aspect, 1, 1000 );
				//camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );

				//camera.position.set( 0.0, radius, radius * 3.5 );
				//camera.position.y = 150;
				camera.position.z = 1000;

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();
				scene.add ( new THREE.AmbientLight( 0xaaaaaa ) );

				var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
				light.position.set( 0, 0, 1000 );
				scene.add( light );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
				renderer.setClearColor( 0xff00ff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = true;

				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function drawGrid() {
			
				var size = 2000;
				var step = 100;

				var gridHelper = new THREE.GridHelper( size, step );
				scene.add( gridHelper );
			}
			
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate);

				//gui.update();

				renderer.render( scene, camera );
			}

			function testItem(){
				var verticesOfCube = [
					-1,-1,-1,    1,-1,-1,    1, 1,-1,    -1, 1,-1,
					-1,-1, 1,    1,-1, 1,    1, 1, 1,    -1, 1, 1,
				];

				var indicesOfFaces = [
					2,1,0,    0,3,2,
					0,4,7,    7,3,0,
					0,1,5,    5,4,0,
					1,2,6,    6,5,1,
					2,3,7,    7,6,2,
					4,5,6,    6,7,4
				];

				var geometry = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 6, 2 );
				
				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors} );

				cube = new THREE.Mesh( geometry, material );
				console.log(cube);
				//cube.position.x = 1000;
				cube.position.z = 1;
				//cube.scale = THREE.Vector3(20, 0, 10);
				scene.add( cube );
			}
			
			function testBox(){
				var geometry = new THREE.BoxGeometry( 200, 200, 200 );

				for ( var i = 0; i < geometry.faces.length; i += 2 ) {

					var hex = Math.random() * 0xffffff;
					geometry.faces[ i ].color.setHex( hex );
					geometry.faces[ i + 1 ].color.setHex( hex );

				}

				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );

				cube = new THREE.Mesh( geometry, material );
				cube.position.y = 150;
				scene.add( cube );

			}
			
			init();
			//testBox();
			//testItem();
			drawGrid();
			animate();
			QF.GuiCrtl.initGui();
		</script>

	</body>
</html>
